<?php

/**
 * @file
 * Authenticated User Page Caching (and anonymous users, too!)
 *
 * @see authcache.admin.inc for admin page functionality
 */

// Default caching rules (Never cache these pages)
define('AUTHCACHE_NOCACHE_DEFAULT', '
user*
node/add/*
node/*/edit
node/*/track
tracker*
comment/edit*
civicrm*
cart*
system/files/*
system/temporary*
');

// Default non-HTML cachable content-types
define('AUTHCACHE_MIMETYPE_DEFAULT', '
text/html
text/javascript
text/plain
application/xml
application/atom+xml
');

// Flags for authcache_fix_cookies:
define('AUTHCACHE_FLAGS_NONE', 0x0);
define('AUTHCACHE_FLAGS_ACCOUNT_ENABLED', 0x1);
define('AUTHCACHE_FLAGS_LOGIN_ACTION', 0x2);
define('AUTHCACHE_FLAGS_LOGOUT_ACTION', 0x4);

/**
 * Implements hook_menu().
 */
function authcache_menu() {

  $items['admin/config/system/authcache'] = array(
    'title' => 'Authcache',
    'description' => 'Configure authenticated user page caching.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('authcache_admin_config'),
    'access arguments' => array('administer site configuration'),
    'file' => 'authcache.admin.inc',
    'weight' => 10,
  );
  
  $items['admin/config/system/authcache/config'] = array(
    'title' => 'Configuration',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  
  $items['admin/config/system/authcache/pagecaching'] = array(
    'title' => 'Page caching settings',
    'description' => "Configure page cache settings.",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('authcache_admin_pagecaching'),
    'access arguments' => array('administer site configuration'),
    'file' => 'authcache.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 20,
  );

  return $items;
}

/**
 * Implements hook_module_implements_alter().
 *
 * Make sure that hook_init of this module is called before all other modules
 * and vice versa for hook_exit.
 */
function authcache_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'init') {
    $me = $implementations['authcache'];
    unset($implementations['authcache']);
    $implementations = array_merge(array('authcache' => $me), $implementations);
  }

  if ($hook == 'exit') {
    $me = $implementations['authcache'];
    unset($implementations['authcache']);
    $implementations['authcache'] = $me;
  }

  if ($hook == 'expire_cache' && variable_get('authcache_cache_handler', 'authcache_builtin_cache_save') != 'authcache_builtin_cache_save') {
    // The authcache implementation hook_expire_cache only makes sense when the
    // builtin cache handler is used.
    unset($implementations['authcache']);
  }
}

/**
 * Implements hook_init().
 */

function authcache_init() {
  global $conf, $user;

  $reasons = module_invoke_all('authcache_request_exclude');
  if (!empty($reasons)) {
    _authcache_exclude(reset($reasons));
  }

  $reasons = module_invoke_all('authcache_account_exclude', $user);
  if (!empty($reasons)) {
    _authcache_exclude(reset($reasons));
  }

  if (!authcache_excluded()) {
    // Don't allow format_date() to use the user's local timezone
    $conf['configurable_timezones'] = FALSE;
  } 

  // Attach required JavaScript
  drupal_add_library('system', 'jquery.cookie');
  drupal_add_js(drupal_get_path('module', 'authcache') . '/authcache.js');

  // Inject authcache cookie settings.
  $lifetime = ini_get('session.cookie_lifetime');
  $lifetime = (!empty($lifetime) && is_numeric($lifetime) ? (int)$lifetime : 0);
  drupal_add_js(array('authcache' => array(
    'q' => $_GET['q'],
    'cp' => array(
      'path' => ini_get('session.cookie_path'),
      'domain' => ini_get('session.cookie_domain'),
      'secure' => ini_get('session.cookie_secure') == '1',
    ),
    'cl' => $lifetime/86400,
  )), 'setting');

  // Fix cookies if necessary.
  $flags = (authcache_account_allows_caching()) ?
    AUTHCACHE_FLAGS_ACCOUNT_ENABLED : AUTHCACHE_FLAGS_NONE;
  authcache_fix_cookies($flags);
}


/**
 * Implements hook_user_login().
 */
function authcache_user_login(&$edit, $account) {
  $flags = AUTHCACHE_FLAGS_LOGIN_ACTION;

  if (authcache_account_allows_caching($account)) {
    $flags |= AUTHCACHE_FLAGS_ACCOUNT_ENABLED;
  }

  authcache_fix_cookies($flags, $account);
}


/**
 * Implements hook_user_logout().
 */
function authcache_user_logout($account) {
  // Note: include same cookie deletion in ajax/authcache.module
  authcache_fix_cookies(AUTHCACHE_FLAGS_LOGOUT_ACTION, $account);
}


/**
 * Implements hook_form_alter(),
 */
function authcache_form_alter(&$form, &$form_state, $form_id) {
  if (authcache_page_is_cacheable()) {
      // Need to postpone the decision whether the form and the page is cacheable
      // to an after-build callback.
      $form['#after_build'][] = '_authcache_form_after_build';
  }

  // Alter all forms
  switch ($form_id) {
    // Alter Drupal's "Performance" admin form
    case 'system_performance_settings':
      $form['caching']['cache']['#description'] = ' <strong>' . t('If Authcache is enabled for the "anonymous user" role, Drupal\'s built-in page caching will be automatically disabled since all page caching is done through Authcache API instead of Drupal core.') . '</strong>';
      if (authcache_account_allows_caching(drupal_anonymous_user())) {
        $form['caching']['cache']['#disabled'] = TRUE; //array(0 => t('Disabled') . ' ' . t('by') . ' Authcache');
        $form['caching']['cache']['#value'] = TRUE;
      }
      
      break;
    case 'user_profile_form':
      // Don't allow user local timezone
      if (authcache_account_allows_caching()) {
        unset($form['timezone']);
      }
      break;
  }
}

/**
 * Form after_build callback for all forms on cacheable pages
 *
 * Disable storing the form to form-cache if possible. However some forms (especially
 * Ajax-enabled ones) require the form cache. In this case page-caching must be
 * cancelled.
 *
 * @see drupal_build_form().
 */
function _authcache_form_after_build($form, $form_state) {
  global $user;

  $form_id = $form['#form_id'];

  if (isset($form['form_token']) && !authcache_get_request_property('ajax')) {
    authcache_cancel(t('Form with CSRF protected on page but cannot use AJAX to defer token-retrieval.'));
  }
  else {
    if (empty($form_state['rebuild']) && empty($form_state['cache'])) {
      // Disable form cache and remove build_id if caching is not explicitely requested
      $form_state['no_cache'] = TRUE;
      unset($form['form_build_id']);
      unset($form['#build_id']);
    }
    elseif ($user->uid) {
      // Remove the build-id hidden field
      unset($form['form_build_id']);

      // Otherwise store prototype-form builds in the cache for authenticated
      // users.
      drupal_add_js(drupal_get_path('module', 'authcache') . '/authcache.formtokenids.js');
      drupal_add_js(array('authcacheFormBuildIds' => array(
        $form_id => $form['#build_id'],
      )), 'setting');
      authcache_ajax_add_command('form_build_id');

      // Prepend 'authcache-' to the build-id. Those builds will serve as
      // prototypes when generating new forms for other users from within
      // AuthcacheFormBuildIdCommand.
      $form['#build_id'] = 'authcache-' . $form['#build_id'];
    }

    if (isset($form['form_token']) && authcache_get_request_property('ajax')) {
      // Remove CSRF-token from built form and make sure it can be retrieved
      // later using AJAX.
      unset($form['form_token']);

      drupal_add_js(drupal_get_path('module', 'authcache') . '/authcache.formtokenids.js');
      drupal_add_js(array('authcacheFormTokenIds' => array(
        $form_id => (isset($form['#token'])) ? $form['#token'] : $form_id,
      )), 'setting');
      authcache_ajax_add_command('form_token_id');
    }
  }

  return $form;
}

/**
 * Implements hook_menu_get_item_alter().
 */
function authcache_menu_get_item_alter(&$router_item, $path, $original_map) {
  $cacheable = authcache_menu_item_cacheable();

  if (!empty($cacheable[$router_item['path']])) {
    $router_item['authcache_cacheable'] = TRUE;
  }
}

/**
 * Process page template variables.
 */
function authcache_preprocess_page(&$variables) {
  if (user_is_logged_in() && authcache_page_is_cacheable()) {
    if (authcache_get_request_property('ajax')) {
      drupal_add_js(drupal_get_path('module', 'authcache') . '/authcache.tabs.js');
      authcache_ajax_add_command('menu_local_tasks');
    }

    if (!_authcache_check_links_cacheable($variables['tabs']['#primary']) ||
      !_authcache_check_links_cacheable($variables['tabs']['#secondary']))
    {
      $variables['tabs']['#post_render'][] = 'authcache_wrap_tabs';
    }

    if (!_authcache_check_links_cacheable($variables['action_links'])) {
      $variables['action_links']['#post_render'][] = 'authcache_wrap_local_actions';
    }
  }
}

/**
 * Check every link in a group if links used in local tasks and actions.
 */
function _authcache_check_links_cacheable($links) {
  if (is_array($links)) {
    foreach ($links as $item) {
      if (!empty($item['#link']['href'])) {
        $router_item = menu_get_item($item['#link']['href']);
        if (empty($router_item['authcache_cacheable'])) {
          return FALSE;
        }
      }
    }
  }

  return TRUE;
}

/**
 * Post-render callback for page-tabs. Wrap them into an authcache span, so we
 * can find it again in JavaScript.
 */
function authcache_wrap_tabs($markup) {
  if (!empty($markup)) {
    if (authcache_get_request_property('ajax')) {
      $markup = '<span id="authcache-tabs">' . $markup . '</span>';
    }
    else {
      authcache_cancel(t('Tabs on page but Authcache AJAX not enabled.'));
    }
  }

  return $markup;
}

/**
 * Post-render callback for local actions. Wrap them into an authcache span, so
 * we can find it again in JavaScript.
 */
function authcache_wrap_local_actions($markup) {
  if (!empty($markup)) {
    if (authcache_get_request_property('ajax')) {
      $markup = '<span id="authcache-local-actions">' . $markup . '</span>';
    }
    else {
      authcache_cancel(t('Local actions on page but Authcache AJAX not enabled.'));
    }
  }

  return $markup;
}

/**
 * Implements hook_exit().
 *
 * Called on drupal_goto() redirect.
 * Make sure status messages show up, if applicable.
 */
function authcache_exit($destination = NULL) {
  // Cancel caching when hook_exit was called from drupal_goto.
  if ($destination !== NULL) {
    authcache_cancel(t('Redirecting to @destination', array('@destination' => $destination)));
  }

  // Disable authcache on next page request if there are messages pending which
  // did not manage it onto the current page.
  if (drupal_set_message()) {
    authcache_fix_cookies(AUTHCACHE_FLAGS_NONE);
  }

  // If this page was excluded in hook_init, we're done here.
  if (authcache_excluded()) {
    return;
  }

  // Forcibly disable drupal built-in page caching for anonymous users.
  // Prevent drupal_page_set_cache() called from drupal_page_footer() to
  // store the page a second time after we did.
  drupal_page_is_cacheable(FALSE);

  // Give other modules a last chance to cancel page saving
  module_invoke_all('authcache_presave');

  if (authcache_page_is_cacheable()) {
    $handler = variable_get('authcache_cache_handler', 'authcache_builtin_cache_save');
    if (is_callable($handler)) {
      call_user_func($handler);
    }
  }
}

//
// Preprocess functions
//

/**
 * Implements hook_preprocess().
 *
 * Inject authcache variables into every template.
 */
function authcache_preprocess(&$variables, $hook) {
  // Define variables for templates files
  $variables['authcache_is_cacheable'] = authcache_page_is_cacheable();
}

/**
 * Implements hook_process_HOOK().
 *
 * Prevent caching pages with status messages on them. Note that due to the
 * fact the messages are only added in template_process_page, we also need to
 * use the process-hook.
 */
function authcache_process_page(&$variables) {
  if (!empty($variables['messages']) && authcache_page_is_cacheable()) {
    authcache_cancel(t('Status message on page'));
  }
}

//
// API for other modules.
//

/**
 * Private function called from authcache_init. Authcache should not alter any
 * aspect of this page.
 */
function _authcache_exclude($reason = NULL) {
  // No need for drupal_static here, flag may not be reset anyway.
  static $excluded = FALSE;

  if (!$excluded && !empty($reason)) {
    $excluded = TRUE;
    module_invoke_all('authcache_excluded', $reason);
  }

  return $excluded;
}

/**
 * Return true if this page is excluded from page caching.
 */
function authcache_excluded() {
  return _authcache_exclude();
}

/**
 * Prevent this page of beeing stored in the cache after it is built up.
 */
function authcache_cancel($reason = NULL) {
  // No need for drupal_static here, flag may not be reset anyway.
  static $cancelled = FALSE;

  if (!$cancelled && !empty($reason)) {
    $cancelled = TRUE;
    module_invoke_all('authcache_cancelled', $reason);
  }

  return $cancelled;
}

/**
 * Return true if the caching of the page request was cancelled during
 * page-build.
 */
function authcache_cancelled() {
  return authcache_cancel();
}

/**
 * Return true if this page possibly will be cached later.
 */
function authcache_page_is_cacheable() {
  return !(authcache_excluded() || authcache_cancelled());
}

/**
 * Return true if the given account is cacheable.
 */
function authcache_account_allows_caching($account = NULL) {
  global $user;
  $cacheable = &drupal_static(__FUNCTION__);

  if (!isset($account)) {
    $account = $user;
  }

  if (!isset($cacheable[$account->uid])) {
    $reasons = module_invoke_all('authcache_account_exclude', $account);
    $cacheable[$account->uid] = empty($reasons);
  }

  return $cacheable[$account->uid];
}

/**
 * Return a map where keys are menu router links and values are booleans.
 */
function authcache_menu_item_cacheable() {
  $menu_item_cacheable = &drupal_static(__FUNCTION__);

  if (!isset($menu_item_cacheable)) {
    $menu_item_cacheable = module_invoke_all('authcache_menu_item_cacheable');
    drupal_alter('authcache_menu_item_cacheable', $menu_item_cacheable);
  }

  return $menu_item_cacheable;
}

/**
 * Return information about available properties and possible values.
 */
function authcache_properties_info() {
  static $info;

  if (!isset($info)) {
    $info = array(
      'request' => module_invoke_all('authcache_request_properties_info'),
      'account' => module_invoke_all('authcache_account_properties_info'),
    );
  }

  return $info;
}

/**
 * Return an associative array where keys correspond to authcache keys and
 * values represent the property record the key is derived from.
 */
function authcache_key_properties_info() {
  static $info;
  if (!isset($info)) {
    module_load_include('inc', 'authcache', 'authcache.comb');

    $properties_info = authcache_properties_info();

    $flatinfo = array();
    $template = array();

    foreach ($properties_info as $group => $properties) {
      foreach ($properties as $key => $definition) {
        $template[] = $definition['choices'];
        $definition['group'] = $group;
        $definition['key'] = $key;
        $flatinfo[] = $definition;
      }
    }

    $expanded = _authcache_expand($template);

    $info = array();
    foreach ($expanded as $record) {
      $properties = array();
      foreach ($record as $key => $value) {
        $definition = $flatinfo[$key];
        $properties[$definition['group']][$definition['key']] = $value;
      }

      $data = serialize($properties);
      $hmac = hash_hmac('sha1', $data, drupal_get_private_key(), FALSE);

      $abbrev = variable_get('authcache_hmac_abbrev', 7);
      $key = $abbrev ? substr($hmac, 0, $abbrev) : $hmac;
      $info[$key] = $properties;
    }

    drupal_alter('authcache_key_properties_info', $info);
  }

  return $info;
}

/**
 * Return a list of cache-keys used by anonymous users.
 */
function authcache_anonymous_keys() {
  static $anonymous_keys;

  if (!isset($info)) {
    $anonymous_keys = module_invoke_all('authcache_anonymous_keys');
    drupal_alter('authcache_anonymous_keys', $anonymous_keys);
  }

  return $anonymous_keys;
}

/**
 * Return a flat list of authcache keys and cache-keys used by anonymous users.
 */
function authcache_enumerate_keys() {
  // Keys for authenticated users
  $authcache_keys = array_keys(authcache_key_properties_info());

  // Keys for anonymous users
  $anonymous_keys = authcache_anonymous_keys();

  return array_merge($authcache_keys, $anonymous_keys);
}

/**
 * Return characterizing key-value pairs of a browsers capabilities and the
 * HTTP request.
 */
function authcache_request_properties() {
  static $properties;

  if (!isset($properties)) {
    $properties = module_invoke_all('authcache_request_properties');
    drupal_alter('authcache_request_properties', $properties);
  }

  return $properties;
}

/**
 * Return characterizing properties of groups the given account is a member of.
 */
function authcache_account_properties($account = NULL) {
  global $user;
  static $properties;

  if (!isset($account)) {
    $account = $user;
  }

  if (!isset($properties)) {
    $properties = module_invoke_all('authcache_account_properties', $account);
    drupal_alter('authcache_account_properties', $properties, $account);
  }

  return $properties;
}

/**
 * Return the property value of the given request property or null.
 *
 * @see hook_authcache_request_properties().
 */
function authcache_get_request_property($name) {
  $properties = authcache_request_properties();
  return isset($properties[$name]) ? $properties[$name] : NULL;
}

/**
 * Return the property value of the given account property or null.
 *
 * @see hook_authcache_account_properties().
 */
function authcache_get_account_property($name, $account = NULL) {
  $properties = authcache_account_properties($account);
  return isset($properties[$name]) ? $properties[$name] : NULL;
}

/**
 * Return the properties used as a base for calculation of the authcache key.
 *
 * @see authcache_key().
 * @see hook_authcache_key_properties_alter().
 */
function authcache_key_properties($account = NULL) {
  global $user;

  if (!isset($account)) {
    $account = $user;
  }

  $properties = array(
    'request' => authcache_request_properties(),
    'account' => authcache_account_properties($account),
  );
  drupal_alter('authcache_key_properties', $properties, $account);

  return $properties;
}

/**
 * Generate and return the authcache key for the given account.
 *
 * @see hook_authcache_key_properties().
 * @see hook_authcache_key_properties_alter().
 */
function authcache_key($account = NULL) {
  global $base_root, $user;

  if (!isset($account)) {
    $account = $user;
  }

  if ($account->uid) {
    // Calculate the key for logged in users from key-properties.
    $data = serialize(authcache_key_properties($account));
    $hmac = hash_hmac('sha1', $data, drupal_get_private_key(), FALSE);

    $abbrev = variable_get('authcache_hmac_abbrev', 7);
    $key = $abbrev ? substr($hmac, 0, $abbrev) : $hmac;
  }
  else {
    // Generate base-key for anonymous users.
    $generator = variable_get('authcache_key_generator');
    if (is_callable($generator)) {
      $key = call_user_func($generator);
    }
    else {
      $key = $base_root;
    }
  }

  return $key;
}

/**
 * Return the authcache cache-id for the given path.
 *
 * @see authcache_key().
 */
function authcache_cid($request_uri = NULL, $account = NULL) {
  if (!isset($request_uri)) {
    $request_uri = request_uri();
  }

  $key = authcache_key($account);
  return $key . $request_uri;
}

/**
 * Add and remove cookies to the browser session as required.
 *
 * @see hook_authcache_cookie().
 * @see hook_authcache_cookie_alter().
 */
function authcache_fix_cookies($flags, $account = NULL) {
  global $user;

  if (!isset($account)) {
    $account = $user;
  }

  $cookies = module_invoke_all('authcache_cookie', $flags, $account);
  drupal_alter('authcache_cookie', $cookies, $flags, $account);

  $default_params = array(
    'present' => FALSE,
    'value' => NULL,
    'lifetime' => ini_get('session.cookie_lifetime'),
    'path' => ini_get('session.cookie_path'),
    'domain' => ini_get('session.cookie_domain'),
    'secure' => ini_get('session.cookie_secure') == '1',
    'httponly' => FALSE,
  );

  foreach ($cookies as $name => $params) {
    $params += $default_params;

    if ($params['present']) {
      // Fix cookie if it is not present in the users browser or the value does
      // not match our expectations.
      if (!isset($_COOKIE[$name]) || $_COOKIE[$name] != $params['value']) {
        $expires = $params['lifetime'] ? REQUEST_TIME + $params['lifetime'] : 0;
        setcookie($name, $params['value'], $expires, $params['path'], $params['domain'], $params['secure'], $params['httponly']);
      }
    }
    elseif (!$params['present'] && isset($_COOKIE[$name])) {
      // Remove spare cookie
      setcookie($name, "", REQUEST_TIME - 86400, $params['path'], $params['domain'], $params['secure'], $params['httponly']);
    }
  }
}

/**
 * Returns an array containing all the roles from account_roles that are not
 * present in allowed_roles.
 */
function authcache_diff_roles($account_roles, $allowed_roles) {
  // Remove "authenticated user"-role from the account roles except when it is
  // the only role on the account.
  if (array_keys($account_roles) != array(DRUPAL_AUTHENTICATED_RID)) {
    unset($account_roles[DRUPAL_AUTHENTICATED_RID]);
  }

  return array_diff_key($account_roles, $allowed_roles);
}

/**
 * Helper function, get authcache user roles
 *
 * @param $all_roles boolean
 *   TRUE when all user roles should be returned, FALSE for authcache-enabled
 *   only.
 *
 * @return array
 *   Associative array of role names keyed by their role-id.
 */
function _authcache_get_roles($all_roles = FALSE) {
  $roles = user_roles();

  // Clarify that the authenticated user-rid will only be considired if the
  // user does not have any other role.
  $roles[DRUPAL_AUTHENTICATED_RID] = t('@authenticated_user (without additional roles)',
     array('@authenticated_user' => $roles[DRUPAL_AUTHENTICATED_RID]));

  if (!$all_roles) {
    $authcache_roles = variable_get('authcache_roles', array());
    $roles = array_intersect_key($roles, $authcache_roles);
  }

  return $roles;
}

/**
 * Determines the MIME content type of the current page response based on
 * the currently set Content-Type HTTP header.
 *
 * This should normally return the string 'text/html' unless another module
 * has overridden the content type.
 */
function _authcache_get_content_type($default = NULL) {
  $params = explode(';', drupal_get_http_header('content-type'));
  $params = array_map('trim', $params);
  $mime = array_shift($params);

  return array(
    'mimetype' => $mime,
    'params' => $params,
  );
}

/**
 * Determines the HTTP response code that the current page request will be
 * returning by examining the HTTP headers that have been output so far.
 */
function _authcache_get_http_status($status = 200) {
  $value = drupal_get_http_header('status');
  return isset($value) ? (int) $value : $status;
}

/**
 * Return default pagecaching rule.
 */
function _authcache_default_pagecaching() {
  // By default restrict default cache roles to anonymous and authenticated
  // users, but only when enabled for authcache.
  $cache_roles = array_intersect_key(
    variable_get('authcache_roles', array()),
    drupal_map_assoc(array(DRUPAL_ANONYMOUS_RID, DRUPAL_AUTHENTICATED_RID)));

  return array(array(
    'option' => 0,
    'pages' => AUTHCACHE_NOCACHE_DEFAULT,
    'noadmin' => 1,
    'roles' => $cache_roles,
  ));
}

/**
 * Default method for enumerating possible combinations of roles. Each item is
 * an array with one or more role-ids forming a role-combination.
 *
 * This approach will build an array with 2^n elements. If you enable more
 * than a couple of roles (say 10) in authcache, then memory consumption and
 * computation time will rise quickly.
 *
 * In order to override this function with your own implementation, set the
 * variable authcache_role_combine to the desired function, e.g. in
 * settings.php:
 *
 *   $conf['authcache_role_combine'] = '_my_function';
 */
function _authcache_default_role_combine() {
  module_load_include('inc', 'authcache', 'authcache.comb');

  $roles = _authcache_get_roles();
  $choices = array();

  // Anonymous users do not have any authcache-key. Therefore there is no need
  // to include this role in the property-info.
  unset($roles[DRUPAL_ANONYMOUS_RID]);

  // The authenticated-user role is exclusive, only include it once. Do not
  // generate combinations including this role.
  if (isset($roles[DRUPAL_AUTHENTICATED_RID])) {
    $choices[] = array(DRUPAL_AUTHENTICATED_RID);
    unset($roles[DRUPAL_AUTHENTICATED_RID]);
  }

  // Combine remaining roles
  $roles = array_keys($roles);
  sort($roles);

  return array_merge($choices, _authcache_comb($roles));
}

//
// Authcache hooks
//

/**
 * Implements hook_authcache_anonymous_keys().
 */
function authcache_authcache_anonymous_keys() {
  global $base_url;

  return variable_get('authcache_key_generator_keys', $base_url);
}

/**
 * Implements hook_authcache_request_properties().
 */
function authcache_authcache_request_properties() {
  global $base_url;

  return array(
    'js' => !empty($_COOKIE['has_js']),
    'base_url' => $base_url,
  );
}

/**
 * Implements hook_authcache_request_properties_info().
 */
function authcache_authcache_request_properties_info() {
  global $base_url;

  return array(
    'js' => array(
      'name' => t('Browser supports JavaScript'),
      'choices' => array(TRUE, FALSE),
    ),
    'base_url' => array(
      'name' => t('Base URL of the site'),
      'choices' => array($base_url),
    ),
  );
}

/**
 * Implements hook_authcache_account_properties().
 */
function authcache_authcache_account_properties($account) {
  $account_roles = $account->roles;

  // Remove "authenticated user"-role from the account roles except when it is
  // the only role on the account.
  if (array_keys($account_roles) != array(DRUPAL_AUTHENTICATED_RID)) {
    unset($account_roles[DRUPAL_AUTHENTICATED_RID]);
  }

  $roles = array_keys($account_roles);
  sort($roles);

  return array(
    'roles' => $roles,
  );
}

/**
 * Implements hook_authcache_account_properties_info().
 */
function authcache_authcache_account_properties_info() {
  module_load_include('inc', 'authcache', 'authcache.comb');

  $func = variable_get('authcache_role_combine', '_authcache_default_role_combine');

  if (function_exists($func)) {
    return array(
      'roles' => array(
        'name' => 'Account roles',
        'choices' => call_user_func($func),
      ),
    );
  }
}

/**
 * Implements hook_authcache_request_exclude().
 */
function authcache_authcache_request_exclude() {
  global $user;

  // The following three basic exclusion rules are mirrored in
  // authcacheinc_retrieve_cache_page() in authcache.inc
  // BEGIN: basic exclusion rules
  if (drupal_is_cli()) {
    return t('Running as CLI script');
  }

  if (!($_SERVER['REQUEST_METHOD'] == 'GET' || $_SERVER['REQUEST_METHOD'] == 'HEAD')) {
    return t('Only GET and HEAD requests allowed. Method for this request is: @method.',
      array('@method' => $_SERVER['REQUEST_METHOD']));
  }

  if (($ar = explode('?', basename(request_uri()))) && substr(array_shift($ar), -4) == '.php') {
    return t('PHP files (cron.php, update.php, etc)');
  }
  // END: basic exclusion rules

  module_load_install('authcache');
  $requirements = module_invoke('authcache', 'requirements', 'runtime');
  if (isset($requirements['authcache']['severity']) && $requirements['authcache']['severity'] == REQUIREMENT_ERROR) {
    return $requirements['authcache']['description'];
  }

  if (variable_get('authcache_noajax', FALSE)
      && isset($_SERVER['HTTP_X_REQUESTED_WITH'])
      && strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) == 'xmlhttprequest'
    ) {
    return t('Ajax request');
  }

  $alias = drupal_get_path_alias($_GET['q']);

  // Now check page caching settings, defined by the site admin
  $pagecaching = variable_get('authcache_pagecaching', _authcache_default_pagecaching());

  foreach ($pagecaching as $i => $page_rules) {
    $rule_num = $i+1;
    // Do caching page roles apply to current user?
    $extra_roles = authcache_diff_roles($user->roles, $page_rules['roles']);
    if (empty($extra_roles)) {
      switch ($page_rules['option']) {
        case '0': // Cache every page except the listed pages.
        case '1': // Cache only the listed pages.
          $page_listed = drupal_match_path($alias, $page_rules['pages']);
          if (!(!($page_rules['option'] xor $page_listed))) {
            return t('Caching disabled by path list of page ruleset #@number', array('@number' => $rule_num));
          }
          break;

        case '2': // Cache pages for which the following PHP code returns TRUE
          $result = 0;
          if (module_exists('php')) {
            $result = php_eval($page_rules['pages']);
          }
          if (empty($result)) {
            return t('Caching disabled by PHP rule of page ruleset #@number', array('@number' => $rule_num));
          }
          break;

        default:
          break;
      }

      if (!empty($page_rules['noadmin']) && path_is_admin(current_path())) {
       return t('Not caching admin pages (by page ruleset #@number)', array('@number' => $rule_num));
      }
    }
  }
}


/**
 * Implements hook_authcache_account_exclude().
 */
function authcache_authcache_account_exclude($account) {
  // Bail out from requests by superuser (uid=1)
  if ($account->uid == 1 && !variable_get('authcache_su', 0)) {
    return t('Caching disabled for superuser');
  }

  // Check for non-cacheable roles of the account.
  $cache_roles = variable_get('authcache_roles', array());
  $extra_roles = authcache_diff_roles($account->roles, $cache_roles);
  if (!empty($extra_roles)) {
    return format_plural(count($extra_roles),
      'Account has non-cachable role @roles',
      'Account has non-cachable roles @roles',
      array('@roles' => implode(', ', $extra_roles)));
  }

  // If JavaScript is disabled on the users browser, check if chaching is still
  // allowed.
  if (!authcache_get_request_property('js')) {
    $nojs_roles = variable_get('authcache_nojsroles', drupal_map_assoc(array(DRUPAL_ANONYMOUS_RID)));
    $extra_roles = authcache_diff_roles($account->roles, $nojs_roles);
    if (!empty($extra_roles)) {
      return format_plural(count($extra_roles),
        'Role @roles is not cacheable if JavaScript is disabled.',
        'Roles @roles are not cacheable if JavaScript is disabled.',
        array('@roles' => implode(', ', $extra_roles)));
    }
  }

  // Ensure that at least one pagecaching rule matches for this account
  $no_rule_matches = TRUE;
  $pagecaching = variable_get('authcache_pagecaching', _authcache_default_pagecaching());
  foreach ($pagecaching as $page_rules) {
    // Do caching page roles apply to the given account?
    $extra_roles = authcache_diff_roles($account->roles, $page_rules['roles']);
    if (empty($extra_roles)) {
      $no_rule_matches = FALSE;
      break;
    }
  }

  if ($no_rule_matches) {
    return t('Account does not match any page caching rule.');
  }
}

/**
 * Implements hook_authcache_menu_item_cacheable().
 */
function authcache_authcache_menu_item_cacheable() {
  global $user;

  $items = array();

  if (user_access('administer nodes')) {
    $no_view_own_unpub = TRUE;
    $no_edit_own = TRUE;
    $no_delete_own = TRUE;
  }
  else {
    $roles = user_role_permissions($user->roles);

    $no_view_own_unpub = !user_access('view own unpublished content');

    $no_edit_own = TRUE;
    foreach ($roles as $rid => $perms) {
      foreach ($perms as $perm) {
        if (substr_compare($perm, 'view own ', 0, 9) === 0 &&
          substr_compare($perm, ' content', -8) === 0)
        {
          $no_edit_own = FALSE;
          break;
        }
      }
    }

    $no_delete_own = TRUE;
    foreach ($roles as $rid => $perms) {
      foreach ($perms as $perm) {
        if (substr_compare($perm, 'delete own ', 0, 11) === 0 &&
          substr_compare($perm, ' content', -8) === 0)
        {
          $no_delete_own = FALSE;
          break;
        }
      }
    }
  }

  // Node module
  $items['node/%'] = $no_view_own_unpub;
  $items['node/%/view'] = $no_view_own_unpub;
  $items['node/%/edit'] = $no_edit_own;
  $items['node/%/delete'] = $no_delete_own;
  $items['node/%/revisions'] = $no_view_own_unpub;
  $items['node/%/revisions/%/view'] = $no_view_own_unpub;
  $items['node/%/revisions/%/revert'] = $no_edit_own;
  $items['node/%/revisions/%/delete'] = $no_delete_own;

  // Aggregator module
  if (module_exists('aggregator')) {
    $items['aggregator/categories/%'] = TRUE;
    $items['aggregator/categories/%/view'] = TRUE;
    $items['aggregator/categories/%/categorize'] = TRUE;
    $items['aggregator/categories/%/configure'] = TRUE;

    $items['aggregator/sources/%'] = TRUE;
    $items['aggregator/sources/%/view'] = TRUE;
    $items['aggregator/sources/%/categorize'] = TRUE;
    $items['aggregator/sources/%/configure'] = TRUE;
  }

  // Book module
  if (module_exists('book')) {
    $items['node/%/outline'] = $no_view_own_unpub;
  }

  // Comment module is handled in authcache_comments

  // Contact module is handled in authcache_contact

  // Openid module
  if (module_exists('openid')) {
    $items['user/%user/openid'] = FALSE;
  }

  // Poll is handled by authcache_poll

  // Search module is handled in authcache_search

  // Shortcut module
  if (module_exists('shortcut')) {
    $items['user/%user/shortcuts'] = FALSE;
  }

  // Statistics module is handled in authcache_statistics

  // Taxonomy module
  if (module_exists('taxonomy')) {
    $items['taxonomy/term/%taxonomy_term'] = TRUE;
    $items['taxonomy/term/%taxonomy_term/view'] = TRUE;
    $items['taxonomy/term/%taxonomy_term/edit'] = TRUE;
  }

  // Tracker module
  if (module_exists('tracker')) {
    $items['tracker'] = TRUE;
    $items['tracker/all'] = TRUE;
    $items['tracker/%'] = FALSE;

    $items['user/%/track'] = FALSE;
    $items['user/%user/track/content'] = FALSE;
  }

  // Translation module
  if (module_exists('translation')) {
    $items['node/%node/translate'] = $no_view_own_unpub;
  }

  // User module
  $items['user'] = TRUE;
  $items['user/login'] = TRUE;
  $items['user/register'] = TRUE;
  $items['user/password'] = TRUE;

  $items['user/%'] = FALSE;
  $items['user/%/view'] = FALSE;
  $items['user/%/edit'] = FALSE;

  return $items;
}

/**
 * Implements hook_authcache_presave().
 */
function authcache_authcache_presave() {
  // Check content-type
  $content_type = _authcache_get_content_type();
  $allowed_mimetypes = preg_split('/(\r\n?|\n)/', variable_get('authcache_mimetype', AUTHCACHE_MIMETYPE_DEFAULT), -1, PREG_SPLIT_NO_EMPTY);
  if (!in_array($content_type['mimetype'], $allowed_mimetypes)) {
    authcache_cancel(t('Only cache allowed HTTP content types (HTML, JS, etc)'));
  }

  // Check http status
  if (variable_get('authcache_http200', FALSE) && _authcache_get_http_status() != 200) {
    authcache_cancel(t('Don`t cache 404/403s/etc'));
  }

  // Check headers already were sent
  if (headers_sent()) {
    authcache_cancel(t('Don`t cache private file transfers or if headers were unexpectly sent.'));
  }

  // Make sure "Location" redirect isn't used
  foreach (headers_list() as $header) {
    if (strpos($header, 'Location:') === 0) {
      authcache_cancel(t('Location header detected'));
    }
  }

  // Don't cache pages with PHP errors (Drupal can't catch fatal errors)
  if (function_exists('error_get_last') && $error = error_get_last()) {
    switch ($error['type']) {
      // Ignore these errors:
      case E_NOTICE: // run-time notices
      case E_USER_NOTICE: // user-generated notice message
      case E_DEPRECATED: // run-time notices
      case E_USER_DEPRECATED: // user-generated notice message
        break;
      default:
        // Let user know there is PHP error and return
        authcache_cancel(t('PHP Error: @error', array('@error' => error_get_last())));
        break;
    }
  }
}


/**
 * Implements hook_authcache_cookie().
 */
function authcache_authcache_cookie($flags, $account) {
  $authenticated = $account->uid;
  $enabled = $flags & AUTHCACHE_FLAGS_ACCOUNT_ENABLED;
  $present = $authenticated && $enabled;

  $cookies['authcache']['present'] = $present;
  $cookies['authcache']['httponly'] = TRUE;
  $cookies['drupal_user']['present'] = $present;
  $cookies['drupal_uid']['present'] = $present;

  if ($present) {
    $cookies['authcache']['value'] =  authcache_key($account);
    $cookies['drupal_user']['value'] =  $account->name;
    $cookies['drupal_uid']['value'] =  $account->uid;
  }

  return $cookies;
}

/**
 * Implements hook_authcache_ajax_command().
 */
function authcache_authcache_ajax_command() {
  return array(
    'form_token_id' => array(
      'handler' => 'AuthcacheFormTokenIdCommand',
      'request' => 'formtoken',
      'request config' => array(
        'maxage' => ini_get('session.cookie_lifetime') ?: 0,
      ),
    ),
    'form_build_id' => array(
      'handler' => 'AuthcacheFormBuildIdCommand',
      'request' => 'formbuild',
      'request config' => array(
        'maxage' => 21600,
      ),
    ),
    'menu_local_tasks' => array(
      'handler' => 'AuthcacheMenuLocalTasksCommand',
      'handler config' => array(
        'bootstrap' => DRUPAL_BOOTSTRAP_FULL,
      ),
      'request' => 'tab',
      'request config' => array(
        'q' => TRUE,
        'maxage' => ini_get('session.cookie_lifetime') ?: 0,
      ),
    ),
  );
}

//
// Authcache built-in storage backend
//

/**
 * Cache storage handler for drupal builtin cache-system
 */
function authcache_builtin_cache_save() {
  $cache = authcache_builtin_page_set_cache();
  drupal_serve_page_from_cache($cache);
}

/**
 * Stores the current page in the drupal builtin cache-system.
 *
 * @see hook_authcache_presave().
 * @see hook_authcache_cache_alter().
 * @see drupal_page_set_cache().
 */
function authcache_builtin_page_set_cache() {
  $cache = (object) array(
    'cid' => authcache_cid(),
    'data' => array(
      'path' => $_GET['q'],
      'body' => ob_get_clean(),
      'title' => drupal_get_title(),
      'headers' => array(),
    ),
    'expire' => CACHE_TEMPORARY,
    'created' => REQUEST_TIME,
  );

  // Restore preferred header names based on the lower-case names returned
  // by drupal_get_http_header().
  $header_names = _drupal_set_preferred_header_name();
  foreach (drupal_get_http_header() as $name_lower => $value) {
    $cache->data['headers'][$header_names[$name_lower]] = $value;
    if ($name_lower == 'expires') {
      // Use the actual timestamp from an Expires header if available.
      $cache->expire = strtotime($value);
    }
  }

  if ($cache->data['body']) {
    if (variable_get('page_compression', TRUE) && extension_loaded('zlib')) {
      $cache->data['body'] = gzencode($cache->data['body'], 9, FORCE_GZIP);
    }

    cache_set($cache->cid, $cache->data, 'cache_page', $cache->expire);
  }
  return $cache;
}

/**
 * Implements hook_expire_cache().
 *
 * Expire cache support for the builtin cache handler
 */
function authcache_expire_cache($urls) {
  $cids = array();

  $keys = authcache_enumerate_keys();
  foreach ($keys as $key) {
    foreach ($urls as $url) {
      // Expire chops the root-slash from request urls. Therefore we need to
      // add it here between the key and the url.
      $cids[] = $key . '/' . $url;
    }
  }

  cache_clear_all($cids, 'cache_page');
}
